**Документ: Описание алгоритма расчёта RTT и обработки тайм-аутов в UDP-клиенте**

---

### 1. Общее описание

Алгоритм реализован в UDP-клиенте, имитирующем поведение утилиты `ping`. Клиент отправляет 10 последовательных UDP-пакетов на сервер и для каждого пакета измеряет **Round-Trip Time (RTT)** — время, прошедшее между отправкой запроса и получением эхо-ответа.  
Если ответ не получен в течение заданного интервала (1 секунда), запрос считается **потерянным**, и фиксируется **тайм-аут**.

---

### 2. Алгоритм расчёта RTT

1. **Момент отправки**:
    - Перед вызовом `sendto()` фиксируется высокоточная временная метка с помощью `std::chrono::high_resolution_clock::now()`. Это значение сохраняется как `start_time`.

2. **Отправка запроса**:
    - Клиент формирует сообщение вида `"Ping <N> <timestamp_ms>"` и отправляет его на сервер через UDP-сокет.

3. **Ожидание ответа**:
    - Клиент вызывает `recvfrom()`, чтобы получить эхо-ответ от сервера.
    - Сокет настроен с таймаутом на приём (`SO_RCVTIMEO = 1 секунда`), поэтому `recvfrom()` автоматически завершится с ошибкой, если ответ не пришёл в течение этого времени.

4. **Момент получения**:
    - При успешном получении ответа (`n >= 0`) фиксируется новая временная метка `end_time`.

5. **Вычисление RTT**:
    - RTT рассчитывается как разность:
      RTT=end_time−start_time
    - Результат преобразуется в **секунды с точностью до миллисекунд** (тип `double`) и сохраняется в список `rtt_list`.

6. **Отображение**:
    - RTT выводится пользователю с точностью до 3 знаков после запятой (мс → с, например: `0.045 сек`).

---

### 3. Обработка тайм-аутов

1. **Настройка таймаута**:
    - При создании сокета устанавливается опция `SO_RCVTIMEO`:
      ```cpp
      struct timeval timeout = {1, 0}; // 1 секунда
      setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));
      ```
    - Это гарантирует, что любой вызов `recvfrom()` будет блокироваться не более 1 секунды.

2. **Обнаружение тайм-аута**:
    - Если `recvfrom()` возвращает значение `< 0`, это означает ошибку.
    - В Linux при установленном `SO_RCVTIMEO` в случае тайм-аута `errno` устанавливается в `EAGAIN` или `EWOULDBLOCK`.
    - Клиент интерпретирует любой отрицательный результат `recvfrom()` как **тайм-аут** (для простоты).

3. **Реакция на тайм-аут**:
    - В консоль выводится сообщение: `"Request timed out"`.
    - Пакет учитывается как **отправленный, но не полученный**.
    - RTT для этого пакета **не сохраняется** в статистику.

---

### 4. Сбор итоговой статистики

После 10 итераций вычисляются следующие метрики:

- **Отправлено**: всегда 10.
- **Получено**: количество успешных `recvfrom()`.
- **Потеряно**: `отправлено – получено`.
- **Процент потерь**:  
  loss_rate = потери / 10 * 100%
- **RTT-статистика** (только по полученным пакетам):
    - Минимальный RTT
    - Максимальный RTT
    - Средний RTT

Если ни один пакет не получен, статистика по RTT не выводится.

---

### 5. Особенности реализации

- Используется **монотонные часы высокого разрешения** (`std::chrono::high_resolution_clock`) для точного измерения интервалов.
- Тайм-аут реализован **на уровне системного вызова**, а не через ручной цикл ожидания — это эффективно и корректно.
- Алгоритм **не использует повторные попытки**: каждый пакет отправляется один раз, что соответствует поведению классического `ping`.

---

### 6. Пример вывода

```
Ответ от сервера: Ping 1 1700000000000, RTT = 0.042 сек
Request timed out
...
Отправлено: 10, Получено: 8, Потеряно: 2 (20.0%)
RTT: мин = 0.038с, макс = 0.056с, средн = 0.045с
```
