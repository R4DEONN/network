### 1. Введение

Данный документ описывает архитектуру и ключевые компоненты пользовательского надёжного протокола передачи данных (Reliable Data Transfer Protocol, RDT), реализованного поверх UDP. Протокол обеспечивает гарантированную, упорядоченную и целостную доставку файлов в условиях возможных потерь, повреждений и задержек пакетов. Основные цели:
- Надёжная передача произвольных бинарных данных;
- Обнаружение и восстановление после потерь пакетов;
- Контроль целостности через контрольную сумму;
- Эффективная передача с использованием скользящего окна.

Протокол реализует упрощённую модель **Go-Back-N (GBN)** с фиксированным размером окна и кумулятивными подтверждениями.

---

### 2. Формат пакета

Все сообщения передаются в виде фиксированной по размеру структуры `RdtpPacket`, выровненной по 1 байту (`#pragma pack(1)`). Это гарантирует одинаковое представление в памяти на всех узлах.

```cpp
struct RdtpPacket {
    uint32_t seq_num;      // Номер последовательности (для DATA)
    uint32_t ack_num;      // Номер подтверждённого пакета (для ACK)
    uint16_t checksum;     // Контрольная сумма всего пакета (кроме самого поля checksum)
    uint16_t flags;        // Флаги: DATA, ACK, FIN
    uint16_t data_len;     // Фактическая длина данных (0–1024)
    char data[1024];       // Полезная нагрузка
};
```

Поля:
- **`seq_num`**: 32-битный номер последовательности, уникальный для каждого DATA-пакета, начинается с 0.
- **`ack_num`**: в ACK-пакетах указывает **номер последнего успешно полученного DATA-пакета**. Подтверждение кумулятивное: получение `ack_num = N` означает, что пакеты `0..N` доставлены.
- **`checksum`**: вычисляется как побитовое XOR всех полей пакета (включая `data`), **с предварительным обнулением поля `checksum`**. Это простой, но эффективный механизм обнаружения однобайтовых и многих многобайтовых ошибок.
- **`flags`**: определяет тип пакета:
    - `FLAG_DATA (0)` — передача данных;
    - `FLAG_ACK (1)` — подтверждение получения;
    - `FLAG_FIN (2)` — сигнал завершения передачи.
- **`data_len`**: количество байт в поле `data`, реально считанных из файла.
- **`data`**: буфер фиксированного размера (1024 байта), заполненный нулями, если данные короче.

Размер пакета: **1040 байт**, что укладывается в MTU Ethernet (1500 байт), избегая фрагментации IP.

---

### 3. Конечный автомат отправителя (Sender FSM)

Отправитель реализует конечный автомат Go-Back-N с таймером на всё окно (а не на отдельные пакеты).

#### Состояния:
- **Ожидание данных для отправки**: формирование пакетов из файла.
- **Передача в пределах окна**: отправка новых пакетов, пока `next_seq_num < base + WINDOW_SIZE`.
- **Ожидание ACK**: после заполнения окна или исчерпания данных — ожидание подтверждения с таймаутом.
- **Ретрансляция**: при истечении таймаута — повторная отправка всех пакетов в текущем окне.

#### События и переходы:
| Событие                                 | Действие                                                                 |
|----------------------------------------|--------------------------------------------------------------------------|
| Данные готовы, окно не заполнено       | Отправить новый DATA-пакет, увеличить `next_seq_num`.                    |
| Получен валидный ACK (`ack_num = N`)   | Установить `base = N + 1`. При `base == total_packets` — завершить передачу. |
| Таймаут                                | Ретранслировать все пакеты от `base` до `next_seq_num - 1`.              |
| Данные исчерпаны, `base == total`      | Отправить 3× FIN-пакет и завершить работу.                               |

Таймер: глобальный на всё окно (`TIMEOUT_MS = 500 мс`). После каждой отправки пакета или получения ACK таймер **не перезапускается** — это упрощение классического GBN, но достаточно для демонстрации.

---

### 4. Конечный автомат получателя (Receiver FSM)

Получатель работает по модели с **фиксированным ожидаемым номером** (`expected_seq_num`). Он не буферизует внеочередные пакеты (характерно для GBN).

#### Состояния:
- **Ожидание пакета `expected_seq_num`**.
- **Обработка завершения (FIN)**.

#### События и переходы:
| Событие                                      | Действие                                                                 |
|---------------------------------------------|--------------------------------------------------------------------------|
| Получен DATA с `seq_num == expected_seq_num`| Записать данные в файл, отправить ACK(`expected_seq_num`), увеличить `expected_seq_num`. |
| Получен DATA с `seq_num ≠ expected_seq_num` | Отправить дублирующий ACK(`expected_seq_num - 1`).                       |
| Получен повреждённый пакет (неверный checksum)| Игнорировать.                                                           |
| Получен FIN                                 | Завершить приём и закрыть файл.                                         |

Получатель **не использует таймеры** — его логика полностью реактивна.

---

### 5. Выбранные алгоритмы

#### 5.1. Go-Back-N ARQ
Выбран в качестве компромисса между простотой (в отличие от Selective Repeat) и эффективностью (в отличие от Stop-and-Wait). Позволяет передавать до `WINDOW_SIZE = 10` пакетов без ожидания ACK, что повышает пропускную способность на каналах с высокой задержкой.

**Особенности реализации**:
- Кумулятивные ACK: один ACK подтверждает все предыдущие пакеты.
- При потере пакета N: все пакеты N, N+1, ..., N+WINDOW_SIZE–1 ретранслируются.
- Размер окна фиксирован, что упрощает управление памятью.

#### 5.2. Контроль целостности (Checksum)
Используется **простой XOR-сумматор** по 16-битным фрагментам. Хотя он уступает CRC-32 или Fletcher в надёжности, он:
- Лёгок в реализации;
- Обеспечивает обнаружение всех однобитовых ошибок и большинства многобитовых;
- Достаточен для учебной демонстрации.

Проверка выполняется на обеих сторонах: отправитель — перед отправкой, получатель — после получения.

#### 5.3. Управление завершением (FIN-handshake)
Для избежания неоднозначности завершения:
- Отправитель посылает **3 копии FIN-пакета** без ожидания подтверждения.
- Получатель завершает работу сразу после первого валидного FIN.
  Такой подход компенсирует возможную потерю FIN-пакета в ненадёжной сети.

---

### 6. Заключение

Описанный протокол обеспечивает базовую надёжность поверх UDP с помощью:
- Скользящего окна (Go-Back-N);
- Контрольных сумм;
- Таймеров и ретрансляций;
- Чёткого разделения состояний отправителя и получателя.

Реализация ориентирована на **простоту, читаемость и учебную ценность**, сохраняя ключевые принципы реальных протоколов (например, TCP). Возможные улучшения: адаптивный таймаут, Selective Repeat, окно переменного размера.