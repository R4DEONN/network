# HighLoadServer
---

## Общая архитектура

Проект построен по принципу **"event-driven I/O + thread pool"**, сочетающего масштабируемость и параллелизм:

```
┌──────────────────────┐
│        main()        │ ← Ожидает SIGINT, управляет жизненным циклом
└──────────┬───────────┘
           ▼
┌──────────────────────┐
│       Server         │ ← Фасад: запускает EpollServer в фоне
└──────────┬───────────┘
           ▼
┌──────────────────────┐
│     EpollServer      │ ← Ядро: epoll + управление соединениями
├──────────────────────┤
│ • epoll event loop   │
│ • graceful shutdown  │
│ • таймауты клиентов  │
└──────────┬───────────┘
           ▼
┌──────────────────────┐
│     ThreadPool       │ ← Пул потоков для CPU-bound задач
└──────────┬───────────┘
           ▼
┌──────────────────────┐
│   Бизнес-логика      │ ← parseQuery, constructQuery, printInfo
└──────────────────────┘
```

---

## Компоненты

### 1. **`main()` — точка входа (Go-style)**
- Парсит аргументы: серверный или клиентский режим.
- В **серверном режиме**:
    - Создаёт `Server`.
    - Запускает его в **отдельном потоке** (`std::thread`).
    - Основной поток **ждёт `SIGINT`/`SIGTERM`** через `sigwait()`.
    - По сигналу вызывает `server.shutdown()` и ждёт завершения.
- **Без глобальных переменных**, без статики — чистая локальная логика.

---

### 2. **`Server` — фасад сервера**
- Обёртка над `EpollServer`.
- Хранит имя сервера и номер (`SERVER_NUMBER = 50`).
- Настраивает обработчик сообщений:
    - Парсит запрос → валидация → логирование → формирование ответа.
- Предоставляет методы:
    - `run()` — запуск event-loop (блокирующий),
    - `shutdown()` — инициация graceful завершения.

---

### 3. **`EpollServer` — ядро I/O**
- Использует **`epoll`** для масштабируемой обработки тысяч соединений.
- **Неблокирующие сокеты** + edge-triggered-like поведение.
- **Управление жизненным циклом клиентов**:
    - Принимает новые подключения.
    - Регистрирует клиентов в `epoll`.
    - Хранит их как `std::unique_ptr<TcpClient>` (RAII).
- **Graceful shutdown**:
    - При вызове `shutdown()` устанавливает `m_stopRequested = true`.
    - Закрывает серверный сокет → новые подключения отклоняются.
    - Ждёт завершения активных клиентов (с таймаутом 15 сек).
- **Таймауты неактивности**:
    - Каждый клиент имеет `lastActivity` timestamp.
    - Каждую секунду проверяются "зависшие" клиенты (>10 сек без данных).
    - Такие клиенты принудительно отключаются.

---

### 4. **`ThreadPool` — конкурентная обработка**
- Простой пул потоков **без `std::future`** (только `void()` задачи).
- Размер по умолчанию = `std::thread::hardware_concurrency()`.
- Используется для:
    - Парсинга запросов,
    - Валидации,
    - Формирования ответа,
    - Логирования.
- **Не блокирует event-loop** — I/O и логика разделены.

---

### 5. **Сетевые примитивы (RAII)**
- **`Socket`** — базовый класс:
    - Обёртка над `int fd`.
    - Автоматическое закрытие в деструкторе.
    - Методы `send`/`recv` с обработкой ошибок (`ECONNRESET` → graceful close).
- **`TcpServer`** — серверный сокет:
    - `bind`, `listen`, `accept`.
- **`TcpClient`** — клиентский сокет:
    - `connect`, `sendString`, `receiveString`.
    - Поддерживает `release()` для передачи владения (но в текущей архитектуре не используется — клиенты хранятся напрямую).

---

### 6. **Бизнес-логика (common/)**
- **`parseQuery`** — извлекает имя и число из строки.
- **`constructQuery`** — формирует ответ: `"Server of X:50"`.
- **`printInfo`** — выводит информацию о взаимодействии.

---

## Потоки и синхронизация

| Поток | Назначение |
|------|-----------|
| **Main thread** | Управление жизненным циклом, ожидание сигнала |
| **Server thread** | `epoll_wait` цикл, приём/чтение данных |
| **Worker threads** (N шт) | Обработка запросов (парсинг, логика) |

**Синхронизация:**
- `std::atomic<bool> m_stopRequested` — для graceful shutdown.
- `std::mutex` в `ThreadPool` — для очереди задач.
- **Нет блокировок в event-loop** — максимальная производительность.

---

## Отказоустойчивость

- **Обработка `ECONNRESET`** — клиенты могут аварийно отключаться.
- **Таймауты** — защита от "буйных" клиентов.
- **Graceful shutdown** — сервер не теряет активные запросы.
- **RAII** — все ресурсы (сокеты, память) освобождаются автоматически.

---

## Масштабируемость

- **I/O**: `epoll` поддерживает десятки тысяч соединений.
- **CPU**: пул потоков использует все ядра.
- **Память**: буферы выделяются на стеке или в куче по необходимости.

---

## Использование

### Сервер:
```bash
./HighLoadServer 8080 "Main"
# Ожидает подключений на :8080
# Ctrl+C → graceful shutdown
```

### Клиент:
```bash
./HighLoadServer 127.0.0.1 8080 "Client1"
# Подключается, отправляет запрос, получает ответ
```

---